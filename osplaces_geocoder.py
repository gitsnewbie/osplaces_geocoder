# -*- coding: utf-8 -*-
"""
/***************************************************************************
 OSPlacesGeoCoder
                                 A QGIS plugin
 This plugin uses OS Places API to search for free text in their AddessBase Premium product, more specifically Local Authority Based Addresses (LPI) stored in the AddressBase Premium
 Bulk of the code is a sloppy lift and shift job of the Nominatmim Locator Filter Plugin Generated by Richard Duivenvoorde: https://qgis.nl/2018/05/16/english-coding-a-qgslocator-plugin/?lang=en
 Includes some redundant code that Richard had left behind..
                              -------------------
        begin                : 2022-09-04
        git sha              : $Format:%H$
        copyright            : (C) 2022 by Sanjay Rana
        email                : sanjay.rana@voa
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

from qgis.core import Qgis, QgsMessageLog, QgsLocatorFilter, QgsLocatorResult, QgsPointXY, \
    QgsCoordinateReferenceSystem, QgsCoordinateTransform, QgsProject, QgsBlockingNetworkRequest, \
    QgsAnnotation, QgsTextAnnotation,QgsAnnotationManager

from qgis.PyQt.QtCore import pyqtSignal, QUrl, QSizeF, QPoint
from qgis.PyQt.QtNetwork import QNetworkRequest
from qgis.PyQt.QtGui import QTextDocument

from qgis.gui import QgsMessageBar, QgsMapCanvasAnnotationItem

import json

class OSPlacesGeocoderPlugin:

    def __init__(self, iface):

        self.iface = iface

        self.filter = OSPlacesGeoCoder(self.iface)

        # THIS is not working?? As in show_problem never called
        self.filter.resultProblem.connect(self.show_problem)
        self.iface.registerLocatorFilter(self.filter)

    def show_problem(self, err):
        self.filter.info("showing problem???")  # never come here?
        self.iface.messageBar().pushWarning("OSPlacesGeoCoder Error", '{}'.format(err))

    def initGui(self):
        pass

    def unload(self):
        self.iface.deregisterLocatorFilter(self.filter)
        #self.filter.resultProblem.disconnect(self.show_problem)


# SEE: https://github.com/qgis/QGIS/blob/master/src/core/locator/qgslocatorfilter.h
#      for all attributes/members/functions to be implemented
class OSPlacesGeoCoder(QgsLocatorFilter):

    USER_AGENT = b'Mozilla/5.0 QGIS OSPlacesGeoCoder'
    
    
    placeServiceUrl = 'https://api.os.uk/search/places/v1/find?dataset=LPI'
    
    # Add your OSDATAHUB API Token for OS Places below
    apiKey = ''
    
    SEARCH_URL = placeServiceUrl + '&key=' + apiKey + '&query='

    resultProblem = pyqtSignal(str)

    def __init__(self, iface):
        # you REALLY REALLY have to save the handle to iface, else segfaults!!
        self.iface = iface
        super(QgsLocatorFilter, self).__init__()

    def name(self):
        return self.__class__.__name__

    def clone(self):
        return OSPlacesGeoCoder(self.iface)

    def displayName(self):
        return 'OS Places Geocoder (end with space to search)'

    def prefix(self):
        return 'osplaces'

    def fetchResults(self, search, context, feedback):
    
        self.info("Started fetching")
        
        if len(search) < 2 or search.rstrip() == self.prefix:
            return

        # "Auto-complete search is not yet supported."
        # so end with a space to trigger a search:
        if search[-1] != ' ':
            return

        self.info("Got something to fetch...")
        
        url = '{}{}'.format(self.SEARCH_URL, search)       
        
        try:

            self.info("Now connecting..")

            # nam = Network Access Manager
            nam = QgsBlockingNetworkRequest()
            request = QNetworkRequest(QUrl(url))
            request.setHeader(QNetworkRequest.UserAgentHeader, self.USER_AGENT)
            nam.get(request, forceRefresh=True)
            reply = nam.reply()
            
            # Print the URL sent for troubleshooting
            self.info("URL Sent: {}".format(url))
                        
            # # self.info(reply.content().data().decode('utf8'))
            
            if reply.attribute(QNetworkRequest.HttpStatusCodeAttribute) == 200:  # other codes are handled by NetworkAccessManager
                content_string = reply.content().data().decode('utf8')
                locations = json.loads(content_string)
                
                self.info("Got a return successfully..now populating options")
                
                for results in locations ['results']:
                    result = QgsLocatorResult()
                    result.filter = self
                    result.displayString = '{} {} {} {}'.format(results['LPI']['UPRN'], ':', results['LPI']['ADDRESS'], '('+results['LPI']['STATUS']+')')
                    # # use the json full item as userData, so all info is in it:
                    result.userData = results['LPI']
                    self.resultFetched.emit(result)
                
                self.info("Finished Parsing")

        except Exception as err:
            # Handle exception..only this one seems to work
            self.info(err)
            self.iface.messageBar().pushMessage("Error", err, level=Qgis.Critical,duration=120)                                  

    def triggerResult(self, result):
    
        self.info("Selected Response: {}".format(result.displayString))        
        
        # Newer Version of PyQT does not expose the .userData (Leading to core dump)
        # Try via get Function, otherwise access attribute
        try:
            doc = result.getUserData()
        except:
            doc = result.userData
            
        x_coordinate = doc['X_COORDINATE']
        y_coordinate = doc['Y_COORDINATE']        
           
        # zoom to the address
        centerPoint = QgsPointXY(float(x_coordinate), float(y_coordinate))
        dest_crs = QgsProject.instance().crs()
        results_crs = QgsCoordinateReferenceSystem.fromEpsgId(27700)
        self.info(dest_crs.description())
        if (dest_crs.description().find('OSGB') < 0):
            aTransform = QgsCoordinateTransform(results_crs, dest_crs, QgsProject.instance())
            centerPointProjected = aTransform.transform(centerPoint)
            aTransform.transform(centerPoint)
            self.iface.mapCanvas().setCenter(centerPointProjected)
        else:
            self.iface.mapCanvas().setCenter(centerPoint)
          
        # zoom to a decent scale
        self.iface.mapCanvas().zoomScale(2500)
        self.iface.mapCanvas().refresh()
        
        self.annotateTheLocation(centerPoint,'LPI: '+result.displayString)       

    def info(self, msg=""):
        QgsMessageLog.logMessage('{} {}'.format(self.__class__.__name__, msg), 'OSPlacesGeoCoder', Qgis.Info)

    def annotateTheLocation(self,location,text):
        
        self.info("about to do some graffiti")
        
        #find any existing annotations created by the Plugin and delete them
        old_annots = QgsProject.instance().annotationManager().annotations()
        for this_annot in old_annots:
           label_text = this_annot.document()
           if (label_text.find("LPI:")):
                QgsProject.instance().annotationManager().removeAnnotation(this_annot)
    
        # create the new annotation
        annot = QgsTextAnnotation()
        annot.setFrameSizeMm(QSizeF(100,30))
        #annot.setMapLayer(layer)
        annot.setFrameOffsetFromReferencePointMm(QPoint(2, 2))
        annot.setDocument(QTextDocument(text))
        
        # X and Y are defined previously
        #annot.setMapPositionCrs(QgsCoordinateReferenceSystem(layer.crs()))
        annot.setMapPosition(location)

        QgsProject.instance().annotationManager().addAnnotation(annot)        
